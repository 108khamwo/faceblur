<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <title>108 Face Blur (Fixed Resizing)</title>
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        body { background-color: #0f172a; color: #f1f5f9; height: 100vh; overflow: hidden; user-select: none; font-family: 'Segoe UI', sans-serif; }
        .canvas-bg {
            background-color: #1e293b;
            background-image: radial-gradient(#334155 1px, transparent 1px);
            background-size: 20px 20px;
        }
        input[type=range] { accent-color: #3b82f6; cursor: pointer; }
        .btn { transition: all 0.2s; } .btn:active { transform: scale(0.95); }
        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-track { background: transparent; }
    </style>
</head>
<body>
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const MODEL_URL = "https://justadudewhohacks.github.io/face-api.js/models";

        const IconsData = {
            Upload: <><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></>,
            Save: <><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>,
            Trash: <><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></>,
            Refresh: <><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></>,
            Eye: <><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></>,
            EyeOff: <><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></>,
            ZoomIn: <><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></>,
            ZoomOut: <><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></>
        };

        const Icon = ({ p, className="" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{p}</svg>
        );

        const App = () => {
            const [images, setImages] = useState([]);
            const [curId, setCurId] = useState(null);
            const [selId, setSelId] = useState(null);
            const [aiStatus, setAiStatus] = useState("init");
            const [isProcessing, setIsProcessing] = useState(false);
            const [showOutlines, setShowOutlines] = useState(true);

            const [defBlur, setDefBlur] = useState(20);
            const [defSoft, setDefSoft] = useState(40);
            const [defShape, setDefShape] = useState('circle');

            const [scale, setScale] = useState(1);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            
            const canvasRef = useRef(null);
            const imgRef = useRef(null);
            const fileRef = useRef(null);
            const interactionRef = useRef({ mode: 'IDLE', start: {x:0, y:0}, offsetStart: {x:0, y:0}, targetId: null, faceStart: {x:0, y:0} });

            const getCurImg = () => images.find(i => i.id === curId);
            const getFaces = () => getCurImg() ? (getCurImg().faces || []) : [];

            // 1. Init AI (Tiny Detector for EXE Stability)
            useEffect(() => {
                const init = async () => {
                    setAiStatus("loading");
                    try {
                        if(window.faceapi) {
                            await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                            setAiStatus("ready");
                        }
                    } catch(e) { console.error("AI Load Error:", e); setAiStatus("error"); }
                };
                init();
            }, []);

            // 2. Load Image
            useEffect(() => {
                const imgData = getCurImg();
                if(!imgData) return;
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = imgData.url;
                img.onload = () => {
                    imgRef.current = img;
                    const cv = canvasRef.current;
                    if(cv) {
                        const cw = cv.parentElement.clientWidth;
                        const ch = cv.parentElement.clientHeight;
                        const fitScale = Math.min(cw / img.naturalWidth, ch / img.naturalHeight) * 0.95;
                        setScale(fitScale);
                        setOffset({ x: (cw - img.naturalWidth * fitScale) / 2, y: (ch - img.naturalHeight * fitScale) / 2 });
                    }
                    setSelId(null);
                    if(!imgData.processed && aiStatus === "ready") detectFaces(img, imgData.id);
                };
            }, [curId, aiStatus]);

            // 3. Fast Detection
            const detectFaces = async (img, targetId) => {
                setIsProcessing(true);
                try {
                    const detCanvas = document.createElement('canvas');
                    const maxDim = 512; 
                    const s = Math.min(1, maxDim / Math.max(img.naturalWidth, img.naturalHeight));
                    detCanvas.width = img.naturalWidth * s;
                    detCanvas.height = img.naturalHeight * s;
                    detCanvas.getContext('2d').drawImage(img, 0, 0, detCanvas.width, detCanvas.height);

                    const dets = await faceapi.detectAllFaces(detCanvas, new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.3 }));

                    const newFaces = dets.map((d, i) => {
                        const b = d.box;
                        const rs = 1/s;
                        const fw = b.width * rs * 1.3;
                        const fh = b.height * rs * 1.4;
                        return {
                            id: Date.now() + i,
                            x: (b.x * rs) + (b.width * rs / 2) - (fw / 2),
                            y: (b.y * rs) + (b.height * rs / 2) - (fh / 2),
                            w: fw,
                            h: fh,
                            blur: defBlur, soft: defSoft, shape: defShape
                        };
                    });
                    setImages(prev => prev.map(item => item.id === targetId ? { ...item, faces: newFaces, processed: true } : item));
                } catch(e) { console.error("Detection Error:", e); }
                setIsProcessing(false);
            };

            const draw = useCallback(() => {
                const cv = canvasRef.current;
                const img = imgRef.current;
                const faces = getFaces();
                if(!cv || !img) return;

                const parent = cv.parentElement;
                if(cv.width !== parent.clientWidth || cv.height !== parent.clientHeight) {
                    cv.width = parent.clientWidth; cv.height = parent.clientHeight;
                }

                const ctx = cv.getContext('2d');
                ctx.clearRect(0, 0, cv.width, cv.height);
                ctx.save();
                ctx.translate(offset.x, offset.y);
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);

                faces.forEach(f => {
                    const cx = f.x + f.w/2, cy = f.y + f.h/2, r = Math.max(f.w, f.h)/2;
                    const isSel = f.id === selId;

                    if(f.soft > 0) {
                        const pad = Math.max(f.soft, f.blur) * 2;
                        const fx = Math.floor(f.x-pad), fy = Math.floor(f.y-pad);
                        const fw = Math.floor(f.w+pad*2), fh = Math.floor(f.h+pad*2);
                        const off = document.createElement('canvas'); off.width = fw; off.height = fh;
                        const o = off.getContext('2d');
                        o.translate(-fx, -fy); o.filter = `blur(${f.blur}px)`; o.drawImage(img, 0, 0); o.setTransform(1,0,0,1,0,0);
                        o.globalCompositeOperation = 'destination-in';
                        o.beginPath();
                        if(f.shape === 'circle') {
                            const g = o.createRadialGradient(fw/2, fh/2, Math.max(0, r - f.soft/2), fw/2, fh/2, r + f.soft/2);
                            g.addColorStop(0, '#000'); g.addColorStop(1, 'transparent'); o.fillStyle = g; o.arc(fw/2, fh/2, r + f.soft, 0, 2*Math.PI);
                        } else {
                            o.fillStyle = 'black'; o.filter = `blur(${f.soft/2}px)`; o.rect((f.x-fx) + f.soft/4, (f.y-fy) + f.soft/4, f.w - f.soft/2, f.h - f.soft/2);
                        }
                        o.fill(); ctx.drawImage(off, fx, fy);
                    } else {
                        ctx.save(); ctx.beginPath();
                        if(f.shape === 'circle') ctx.arc(cx, cy, r, 0, 2*Math.PI); else ctx.rect(f.x, f.y, f.w, f.h);
                        ctx.clip(); ctx.filter = `blur(${f.blur}px)`; ctx.drawImage(img, 0, 0); ctx.restore();
                    }

                    if(showOutlines || isSel) {
                        const lw = 2/scale; ctx.lineWidth = isSel ? lw*2 : lw; ctx.strokeStyle = isSel ? '#3b82f6' : 'rgba(255,255,255,0.6)';
                        ctx.setLineDash(isSel ? [] : [lw*3, lw*2]); ctx.beginPath();
                        if(f.shape==='circle') ctx.arc(cx, cy, r, 0, 2*Math.PI); else ctx.rect(f.x, f.y, f.w, f.h); ctx.stroke();
                        if(isSel) { ctx.fillStyle='#3b82f6'; ctx.beginPath(); ctx.arc(f.x+f.w, f.y+f.h, lw*5, 0, 2*Math.PI); ctx.fill(); }
                    }
                });
                ctx.restore();
            }, [images, curId, selId, showOutlines, offset, scale]);

            useEffect(() => { let id = requestAnimationFrame(draw); return () => cancelAnimationFrame(id); }, [draw]);

            // Interaction
            const getPos = (e) => {
                const r = canvasRef.current.getBoundingClientRect();
                return { x: (e.clientX - r.left - offset.x)/scale, y: (e.clientY - r.top - offset.y)/scale };
            };

            const onMouseDown = (e) => {
                if(!imgRef.current) return;
                const p = getPos(e); const faces = getFaces();
                const hit = [...faces].reverse().find(f => {
                    if(f.shape==='circle') return Math.hypot(p.x-(f.x+f.w/2), p.y-(f.y+f.h/2)) <= Math.max(f.w,f.h)/2;
                    return p.x>=f.x && p.x<=f.x+f.w && p.y>=f.y && p.y<=f.y+f.h;
                });
                if(hit) {
                    setSelId(hit.id); interactionRef.current = { mode: 'DRAG', start: p, faceStart: {x: hit.x, y: hit.y}, targetId: hit.id };
                } else {
                    if(e.button === 0 && !e.shiftKey) {
                        const s = Math.min(imgRef.current.naturalWidth, imgRef.current.naturalHeight) * 0.15;
                        const nf = { id: Date.now(), x: p.x-s/2, y: p.y-s/2, w: s, h: s, blur: defBlur, soft: defSoft, shape: defShape };
                        setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: [...img.faces, nf] } : img));
                        setSelId(nf.id); interactionRef.current = { mode: 'DRAG', start: p, faceStart: {x: nf.x, y: nf.y}, targetId: nf.id };
                    } else { interactionRef.current = { mode: 'PAN', start: {x: e.clientX, y: e.clientY}, offsetStart: {...offset} }; }
                }
            };

            const onMouseMove = (e) => {
                const { mode, start, faceStart, offsetStart, targetId } = interactionRef.current;
                if(mode === 'DRAG') {
                    const p = getPos(e); const dx = p.x - start.x, dy = p.y - start.y;
                    setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: img.faces.map(f => f.id === targetId ? {...f, x: faceStart.x + dx, y: faceStart.y + dy} : f) } : img));
                } else if(mode === 'PAN') {
                    const dx = e.clientX - start.x, dy = e.clientY - start.y;
                    setOffset({ x: offsetStart.x + dx, y: offsetStart.y + dy });
                }
            };

            // Fixed Resize Logic: Keep Center Point
            const handleResize = (newSize) => {
                if(!selId) return;
                setImages(prev => prev.map(img => {
                    if(img.id !== curId) return img;
                    return {
                        ...img,
                        faces: img.faces.map(f => {
                            if(f.id !== selId) return f;
                            const cx = f.x + f.w/2;
                            const cy = f.y + f.h/2;
                            return { ...f, w: newSize, h: newSize, x: cx - newSize/2, y: cy - newSize/2 };
                        })
                    };
                }));
            };

            const updateSel = (k, v) => setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: img.faces.map(f => f.id === selId ? {...f, [k]:v} : f) } : img));
            const updateGlobal = (k, v) => {
                if(k==='blur') setDefBlur(v); if(k==='soft') setDefSoft(v);
                setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: img.faces.map(f => ({...f, [k]:v})) } : img));
            };

            const saveImage = () => {
                const cv = document.createElement('canvas'); const img = imgRef.current;
                cv.width = img.naturalWidth; cv.height = img.naturalHeight;
                const x = cv.getContext('2d'); x.drawImage(img, 0, 0);
                getFaces().forEach(f => {
                    const cx = f.x+f.w/2, cy = f.y+f.h/2, r = Math.max(f.w, f.h)/2;
                    if(f.soft > 0) {
                        const pad = Math.max(f.soft, f.blur)*2;
                        const off = document.createElement('canvas'); off.width=f.w+pad*2; off.height=f.h+pad*2;
                        const o = off.getContext('2d'); o.translate(-(f.x-pad), -(f.y-pad)); o.filter=`blur(${f.blur}px)`; o.drawImage(img,0,0); o.setTransform(1,0,0,1,0,0);
                        o.globalCompositeOperation='destination-in'; o.beginPath();
                        if(f.shape==='circle') {
                            const g=o.createRadialGradient(off.width/2,off.height/2,Math.max(0,r-f.soft/2),off.width/2,off.height/2,r+f.soft/2);
                            g.addColorStop(0,'#000'); g.addColorStop(1,'transparent'); o.fillStyle=g; o.arc(off.width/2,off.height/2,r+f.soft,0,2*Math.PI);
                        } else {
                            o.fillStyle='black'; o.shadowColor='black'; o.shadowBlur=f.soft; o.rect(pad+f.soft/2, pad+f.soft/2, f.w-f.soft, f.h-f.soft);
                        }
                        o.fill(); x.drawImage(off, f.x-pad, f.y-pad);
                    } else {
                        x.save(); x.beginPath(); if(f.shape==='circle') x.arc(cx,cy,r,0,2*Math.PI); else x.rect(f.x,f.y,f.w,f.h);
                        x.clip(); x.filter=`blur(${f.blur}px)`; x.drawImage(img,0,0); x.restore();
                    }
                });
                const a = document.createElement('a'); a.download = '108FaceBlur_HQ.jpg'; a.href = cv.toDataURL('image/jpeg', 1.0); a.click();
            };

            const handleFile = async (e) => {
                const files = Array.from(e.target.files);
                const newImgs = await Promise.all(files.map(f => new Promise(res => {
                    const r = new FileReader(); r.onload = (ev) => {
                        const i = new Image(); i.onload = () => res({ id: Math.random().toString(), url: ev.target.result, name: f.name, faces: [], processed: false });
                        i.src = ev.target.result;
                    }; r.readAsDataURL(f);
                })));
                setImages(p => [...p, ...newImgs]); if(!curId && newImgs.length) setCurId(newImgs[0].id);
                e.target.value = "";
            };

            const selFace = getFaces().find(f => f.id === selId);

            return (
                <div className="flex h-full font-sans text-gray-100">
                    <div className="w-80 bg-slate-800 border-r border-slate-700 flex flex-col z-20 shadow-xl">
                        <div className="p-4 border-b border-slate-700 font-bold text-xl text-blue-400 flex justify-between items-center">
                            108 Face Blur <span className={`text-xs px-2 py-0.5 rounded ${aiStatus==='ready'?'bg-green-900 text-green-400':'bg-yellow-900 text-yellow-400'}`}>{aiStatus==='ready'?'Ready':'Loading'}</span>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-6">
                            <div className="space-y-2">
                                <button onClick={()=>fileRef.current.click()} className="btn w-full py-3 bg-blue-600 hover:bg-blue-500 rounded font-bold flex items-center justify-center gap-2 text-white">
                                    <Icon p={IconsData.Upload}/> อัปโหลดรูปภาพ
                                </button>
                                <input ref={fileRef} type="file" className="hidden" multiple accept="image/*" onChange={handleFile}/>
                                {images.length > 0 && <div className="flex gap-2 overflow-x-auto pb-2 no-scrollbar">{images.map(img => (
                                    <div key={img.id} onClick={()=>setCurId(img.id)} className={`relative flex-none w-14 h-14 rounded border-2 cursor-pointer ${curId===img.id?'border-blue-500':'border-transparent opacity-50'}`}><img src={img.url} className="w-full h-full object-cover rounded-sm"/></div>
                                ))}</div>}
                            </div>
                            <hr className="border-slate-700"/>
                            {selFace ? (
                                <div className="bg-yellow-500/10 border border-yellow-500/20 p-4 rounded-lg space-y-4">
                                    <div className="flex justify-between font-bold text-yellow-500"><span>ปรับแต่งจุดที่เลือก</span><button onClick={()=>{setImages(prev=>prev.map(img=>img.id===curId?{...img, faces: img.faces.filter(f=>f.id!==selId)}:img)); setSelId(null);}} className="text-red-400"><Icon p={IconsData.Trash}/></button></div>
                                    <div><div className="text-xs mb-1">ขนาด (ขยายจากศูนย์กลาง)</div><input type="range" min="10" max="1500" value={selFace.w} onChange={e=>handleResize(Number(e.target.value))} className="w-full"/></div>
                                    <div><div className="text-xs mb-1">เบลอ</div><input type="range" min="0" max="100" value={selFace.blur} onChange={e=>updateSel('blur', Number(e.target.value))} className="w-full"/></div>
                                    <div><div className="text-xs mb-1">ความฟุ้งขอบ</div><input type="range" min="0" max="150" value={selFace.soft} onChange={e=>updateSel('soft', Number(e.target.value))} className="w-full"/></div>
                                    <div className="flex gap-2">
                                        <button onClick={()=>updateSel('shape','circle')} className={`flex-1 py-1 rounded text-xs border ${selFace.shape==='circle'?'bg-yellow-600 border-yellow-600 text-black':'border-slate-600'}`}>วงกลม</button>
                                        <button onClick={()=>updateSel('shape','square')} className={`flex-1 py-1 rounded text-xs border ${selFace.shape==='square'?'bg-yellow-600 border-yellow-600 text-black':'border-slate-600'}`}>สี่เหลี่ยม</button>
                                    </div>
                                    <button onClick={()=>setSelId(null)} className="w-full py-2 bg-slate-700 rounded text-sm mt-2 font-bold">บันทึกจุดนี้</button>
                                </div>
                            ) : (
                                <div className="space-y-4 text-slate-300">
                                    <div className="font-bold text-sm">ค่าเริ่มต้น (Global)</div>
                                    <div><div className="text-xs mb-1">ความเบลอ</div><input type="range" min="0" max="100" value={defBlur} onChange={e=>updateGlobal('blur', Number(e.target.value))} className="w-full"/></div>
                                    <div><div className="text-xs mb-1">ความฟุ้งขอบ</div><input type="range" min="0" max="100" value={defSoft} onChange={e=>updateGlobal('soft', Number(e.target.value))} className="w-full"/></div>
                                    <div className="pt-4 space-y-2 border-t border-slate-700">
                                        <button onClick={()=>{if(imgRef.current) detectFaces(imgRef.current, curId)}} disabled={isProcessing} className="w-full py-2 bg-slate-700 hover:bg-slate-600 rounded flex justify-center items-center gap-2 text-sm">{isProcessing ? <span className="spinner"><Icon p={IconsData.Refresh}/></span> : <Icon p={IconsData.Refresh}/>} สแกนหน้าซ้ำ</button>
                                        <button onClick={()=>setShowOutlines(!showOutlines)} className="w-full py-2 bg-slate-700 hover:bg-slate-600 rounded flex justify-center items-center gap-2 text-sm">{showOutlines ? <><Icon p={IconsData.Eye}/> ซ่อนกรอบ</> : <><Icon p={IconsData.EyeOff}/> แสดงกรอบ</>}</button>
                                    </div>
                                </div>
                            )}
                        </div>
                        {curId && <div className="p-4 border-t border-slate-700"><button onClick={saveImage} className="w-full py-3 bg-green-600 hover:bg-green-500 rounded font-bold shadow-lg flex justify-center items-center gap-2 btn"><Icon p={IconsData.Save}/> บันทึกภาพ (Full HQ)</button></div>}
                    </div>

                    <div className="flex-1 bg-black canvas-container flex items-center justify-center overflow-auto p-4 relative" 
                         onMouseDown={onMouseDown} onMouseMove={onMouseMove} onMouseUp={()=>interactionRef.current.mode='IDLE'} 
                         onWheel={(e)=>setScale(s=>Math.max(0.05, Math.min(10, s*(1-e.deltaY*0.001))))}>
                        {!curId ? (
                            <div className="text-center text-slate-500 p-10 border-2 border-dashed border-slate-700 rounded-xl cursor-pointer hover:border-slate-500" onClick={()=>fileRef.current.click()}>
                                <Icon p={IconsData.Upload} className="w-16 h-16 mx-auto mb-4"/>
                                <h2 className="text-xl font-bold">อัปโหลดรูปภาพ</h2>
                                <p className="text-sm mt-2">เพื่อเริ่มใช้งานแบบพกพา</p>
                            </div>
                        ) : (
                            <div className="relative" style={{width:'100%', height:'100%', display:'flex', alignItems:'center', justifyContent:'center'}}>
                                <canvas ref={canvasRef} className="shadow-2xl cursor-crosshair"/>
                                <div className="absolute bottom-4 right-4 flex flex-col gap-2 z-10">
                                    <button onClick={(e)=>{e.stopPropagation(); setScale(s=>Math.min(s*1.2, 10));}} className="p-2 bg-slate-800/90 rounded-full text-white shadow-lg border border-slate-600 hover:bg-slate-700 btn"><Icon p={IconsData.ZoomIn}/></button>
                                    <button onClick={(e)=>{e.stopPropagation(); setScale(s=>Math.max(s/1.2, 0.05));}} className="p-2 bg-slate-800/90 rounded-full text-white shadow-lg border border-slate-600 hover:bg-slate-700 btn"><Icon p={IconsData.ZoomOut}/></button>
                                </div>
                            </div>
                        )}
                        {isProcessing && <div className="absolute inset-0 bg-black/60 flex items-center justify-center z-50"><div className="bg-white text-black px-6 py-3 rounded-full font-bold flex gap-3 shadow-2xl animate-pulse"><RefreshCw className="spinner w-5 h-5"/> กำลังสแกนหาใบหน้า...</div></div>}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
