<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <title>108 Face Blur (Pro Interaction v15)</title>
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        body { background-color: #0f172a; color: #f1f5f9; height: 100vh; overflow: hidden; user-select: none; font-family: 'Segoe UI', sans-serif; }
        .canvas-bg {
            background-color: #1e293b;
            background-image: radial-gradient(#334155 1px, transparent 1px);
            background-size: 20px 20px;
        }
        input[type=range] { accent-color: #3b82f6; cursor: pointer; }
        .btn { transition: all 0.2s; } .btn:active { transform: scale(0.95); }
        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-track { background: transparent; }
    </style>
</head>
<body>
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const MODEL_URL = "https://justadudewhohacks.github.io/face-api.js/models";

        const IconsData = {
            Upload: <><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></>,
            Save: <><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>,
            Trash: <><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></>,
            Refresh: <><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></>,
            Eye: <><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></>,
            EyeOff: <><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></>,
            ZoomIn: <><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></>,
            ZoomOut: <><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></>,
            Undo: <><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></>
        };

        const Icon = ({ p, className="" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{p}</svg>
        );

        const App = () => {
            const [images, setImages] = useState([]);
            const [curId, setCurId] = useState(null);
            const [selId, setSelId] = useState(null);
            const [aiStatus, setAiStatus] = useState("init");
            const [isProcessing, setIsProcessing] = useState(false);
            const [showOutlines, setShowOutlines] = useState(true);
            const [history, setHistory] = useState([]);

            const [defBlur, setDefBlur] = useState(25);
            const [defSoft, setDefSoft] = useState(45);
            const [defShape, setDefShape] = useState('circle');

            const [scale, setScale] = useState(1);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            
            const canvasRef = useRef(null);
            const imgRef = useRef(null);
            const fileRef = useRef(null);
            
            // Ref สำหรับจัดการ Interaction แบบ Real-time
            const interactionRef = useRef({ 
                mode: 'IDLE', 
                start: {x:0, y:0}, 
                offsetStart: {x:0, y:0}, 
                targetId: null, 
                faceStart: {x:0, y:0},
                hasMoved: false 
            });

            const getCurImg = () => images.find(i => i.id === curId);
            const getFaces = () => getCurImg() ? (getCurImg().faces || []) : [];

            // History Management
            const saveToHistory = useCallback(() => {
                const currentFaces = getFaces();
                setHistory(prev => [...prev.slice(-19), JSON.parse(JSON.stringify(currentFaces))]);
            }, [images, curId]);

            const handleUndo = useCallback(() => {
                if (history.length === 0) return;
                const lastState = history[history.length - 1];
                setHistory(prev => prev.slice(0, -1));
                setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: lastState } : img));
                setSelId(null);
            }, [history, curId]);

            // AI Init
            useEffect(() => {
                const initAI = async () => {
                    setAiStatus("loading");
                    try {
                        if (window.faceapi) {
                            await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                            await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
                            setAiStatus("ready");
                        } else {
                            setTimeout(initAI, 1000);
                        }
                    } catch(e) { setAiStatus("error"); }
                };
                initAI();
            }, []);

            // Detection Logic
            const detectFaces = async (img, targetId) => {
                if (!window.faceapi || isProcessing) return;
                saveToHistory();
                setIsProcessing(true);
                try {
                    const detCanvas = document.createElement('canvas');
                    const maxDim = 800; 
                    const s = Math.min(1, maxDim / Math.max(img.naturalWidth, img.naturalHeight));
                    detCanvas.width = img.naturalWidth * s;
                    detCanvas.height = img.naturalHeight * s;
                    detCanvas.getContext('2d').drawImage(img, 0, 0, detCanvas.width, detCanvas.height);

                    let dets = await faceapi.detectAllFaces(detCanvas, new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.3 }));
                    if (dets.length === 0) {
                        dets = await faceapi.detectAllFaces(detCanvas, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.4 }));
                    }

                    const newFaces = dets.map((d, i) => {
                        const b = d.box;
                        const rs = 1/s;
                        const fw = b.width * rs * 1.35;
                        const fh = b.height * rs * 1.45;
                        return {
                            id: Date.now() + i,
                            x: (b.x * rs) + (b.width * rs / 2) - (fw / 2),
                            y: (b.y * rs) + (b.height * rs / 2) - (fh / 2),
                            w: fw, h: fh,
                            blur: defBlur, soft: defSoft, shape: defShape
                        };
                    });
                    setImages(prev => prev.map(item => item.id === targetId ? { ...item, faces: newFaces, processed: true } : item));
                } catch(e) { console.error(e); }
                setIsProcessing(false);
            };

            // Image Load Handler
            useEffect(() => {
                const data = getCurImg();
                if(!data) return;
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = data.url;
                img.onload = () => {
                    imgRef.current = img;
                    const cv = canvasRef.current;
                    if(cv) {
                        const cw = cv.parentElement.clientWidth, ch = cv.parentElement.clientHeight;
                        const fit = Math.min(cw / img.naturalWidth, ch / img.naturalHeight) * 0.9;
                        setScale(fit);
                        setOffset({ x: (cw - img.naturalWidth * fit)/2, y: (ch - img.naturalHeight * fit)/2 });
                    }
                    setSelId(null);
                    setHistory([]);
                    if(!data.processed && aiStatus === "ready") {
                        setTimeout(() => detectFaces(img, data.id), 500);
                    }
                };
            }, [curId, aiStatus]);

            // Drawing Engine
            const drawFaces = (ctx, img, faces, viewScale) => {
                faces.forEach(f => {
                    const cx = f.x + f.w/2, cy = f.y + f.h/2, r = Math.max(f.w, f.h)/2;
                    const isSel = f.id === selId;

                    if(f.soft > 0) {
                        const pad = Math.max(f.soft, f.blur) * 2.5; 
                        const fx = Math.floor(f.x - pad), fy = Math.floor(f.y - pad);
                        const fw = Math.floor(f.w + pad * 2), fh = Math.floor(f.h + pad * 2);
                        const off = document.createElement('canvas'); off.width = fw; off.height = fh;
                        const oCtx = off.getContext('2d');
                        oCtx.translate(-fx, -fy);
                        oCtx.filter = `blur(${f.blur}px)`;
                        oCtx.drawImage(img, 0, 0);
                        oCtx.setTransform(1,0,0,1,0,0);
                        oCtx.globalCompositeOperation = 'destination-in';
                        oCtx.beginPath();
                        oCtx.filter = `blur(${f.soft}px)`;
                        oCtx.fillStyle = 'white';
                        if(f.shape === 'circle') oCtx.arc(fw/2, fh/2, r - (f.soft/2), 0, Math.PI*2);
                        else oCtx.rect(pad + (f.soft/2), pad + (f.soft/2), f.w - f.soft, f.h - f.soft);
                        oCtx.fill();
                        ctx.drawImage(off, fx, fy);
                    } else {
                        ctx.save(); ctx.beginPath();
                        if(f.shape === 'circle') ctx.arc(cx, cy, r, 0, Math.PI*2);
                        else ctx.rect(f.x, f.y, f.w, f.h);
                        ctx.clip(); ctx.filter = `blur(${f.blur}px)`; ctx.drawImage(img, 0, 0); ctx.restore();
                    }

                    if(showOutlines || isSel) {
                        const lw = 2/viewScale;
                        ctx.save();
                        ctx.lineWidth = isSel ? lw*2 : lw;
                        ctx.strokeStyle = isSel ? '#3b82f6' : 'rgba(255,255,255,0.4)';
                        ctx.setLineDash(isSel ? [] : [lw*5, lw*3]);
                        ctx.beginPath();
                        if(f.shape==='circle') ctx.arc(cx, cy, r, 0, Math.PI*2);
                        else ctx.rect(f.x, f.y, f.w, f.h);
                        ctx.stroke();
                        if(isSel) {
                            ctx.fillStyle = '#3b82f6'; ctx.beginPath();
                            ctx.arc(f.x+f.w, f.y+f.h, lw*6, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                    }
                });
            };

            const draw = useCallback(() => {
                const cv = canvasRef.current;
                const img = imgRef.current;
                const faces = getFaces();
                if(!cv || !img) return;

                const parent = cv.parentElement;
                if(cv.width !== parent.clientWidth || cv.height !== parent.clientHeight) {
                    cv.width = parent.clientWidth; cv.height = parent.clientHeight;
                }

                const ctx = cv.getContext('2d');
                ctx.clearRect(0, 0, cv.width, cv.height);
                ctx.save();
                ctx.translate(offset.x, offset.y);
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);
                drawFaces(ctx, img, faces, scale);
                ctx.restore();
            }, [images, curId, selId, showOutlines, offset, scale]);

            useEffect(() => {
                const id = requestAnimationFrame(draw);
                return () => cancelAnimationFrame(id);
            }, [draw]);

            // Interaction Helpers
            const getPos = (e) => {
                const r = canvasRef.current.getBoundingClientRect();
                return { x: (e.clientX - r.left - offset.x)/scale, y: (e.clientY - r.top - offset.y)/scale };
            };

            const onMouseDown = (e) => {
                if(!imgRef.current) return;
                const p = getPos(e); const faces = getFaces();
                const hit = [...faces].reverse().find(f => {
                    if(f.shape==='circle') return Math.hypot(p.x-(f.x+f.w/2), p.y-(f.y+f.h/2)) <= Math.max(f.w,f.h)/2;
                    return p.x>=f.x && p.x<=f.x+f.w && p.y>=f.y && p.y<=f.y+f.h;
                });

                interactionRef.current.start = { x: e.clientX, y: e.clientY };
                interactionRef.current.hasMoved = false;

                if(hit) {
                    saveToHistory();
                    setSelId(hit.id);
                    interactionRef.current.mode = 'DRAG';
                    interactionRef.current.faceStart = { x: hit.x, y: hit.y };
                    interactionRef.current.targetId = hit.id;
                    interactionRef.current.posStart = p;
                } else {
                    // หากคลิกที่พื้นที่ว่าง เริ่มโหมด PAN เพื่อเลื่อนภาพ
                    interactionRef.current.mode = 'PAN';
                    interactionRef.current.offsetStart = { ...offset };
                }
            };

            const onMouseMove = (e) => {
                const ir = interactionRef.current;
                const dx = e.clientX - ir.start.x;
                const dy = e.clientY - ir.start.y;

                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                    ir.hasMoved = true;
                }

                if(ir.mode === 'DRAG') {
                    const r = canvasRef.current.getBoundingClientRect();
                    const p = { x: (e.clientX - r.left - offset.x)/scale, y: (e.clientY - r.top - offset.y)/scale };
                    const deltaX = p.x - ir.posStart.x;
                    const deltaY = p.y - ir.posStart.y;
                    
                    setImages(prev => prev.map(img => img.id === curId ? { 
                        ...img, 
                        faces: img.faces.map(f => f.id === ir.targetId ? {
                            ...f, x: ir.faceStart.x + deltaX, y: ir.faceStart.y + deltaY
                        } : f) 
                    } : img));
                } else if(ir.mode === 'PAN') {
                    setOffset({ x: ir.offsetStart.x + dx, y: ir.offsetStart.y + dy });
                }
            };

            const onMouseUp = (e) => {
                const ir = interactionRef.current;
                // ถ้าเป็นการคลิกพื้นที่ว่างสั้นๆ (ไม่ได้ลาก) ให้ทำการเพิ่มจุดเบลอ
                if (ir.mode === 'PAN' && !ir.hasMoved && e.button === 0) {
                    const p = getPos(e);
                    saveToHistory();
                    const s = Math.min(imgRef.current.naturalWidth, imgRef.current.naturalHeight) * 0.15;
                    const nf = { id: Date.now(), x: p.x-s/2, y: p.y-s/2, w: s, h: s, blur: defBlur, soft: defSoft, shape: defShape };
                    setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: [...img.faces, nf] } : img));
                    setSelId(nf.id);
                }
                ir.mode = 'IDLE';
            };

            // Keyboard
            useEffect(() => {
                const h = (e) => {
                    if ((e.key === 'Delete' || e.key === 'Backspace') && selId) {
                        saveToHistory();
                        setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: img.faces.filter(f => f.id !== selId) } : img));
                        setSelId(null);
                    }
                    if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); handleUndo(); }
                };
                window.addEventListener('keydown', h);
                return () => window.removeEventListener('keydown', h);
            }, [selId, curId, handleUndo]);

            const updateSel = (key, val) => {
                setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: img.faces.map(f => f.id === selId ? (key === 'w' ? { ...f, w: val, h: val, x: (f.x + f.w/2) - val/2, y: (f.y + f.h/2) - val/2 } : { ...f, [key]: val }) : f) } : img));
            };

            const updateGlobal = (key, val) => {
                if(key === 'blur') setDefBlur(val);
                if(key === 'soft') setDefSoft(val);
                setImages(prev => prev.map(img => img.id === curId ? { ...img, faces: img.faces.map(f => ({ ...f, [key]: val })) } : img));
            };

            const saveImage = () => {
                const img = imgRef.current; if(!img) return;
                const cv = document.createElement('canvas'); cv.width = img.naturalWidth; cv.height = img.naturalHeight;
                const ctx = cv.getContext('2d'); ctx.drawImage(img, 0, 0);
                drawFaces(ctx, img, getFaces(), 1); 
                const a = document.createElement('a'); a.download = 'Blurred_Export.jpg'; a.href = cv.toDataURL('image/jpeg', 1.0); a.click();
            };

            const selFace = getFaces().find(f => f.id === selId);

            return (
                <div className="flex h-full font-sans text-gray-100 overflow-hidden">
                    {/* Sidebar */}
                    <div className="w-80 bg-slate-800 border-r border-slate-700 flex flex-col z-20 shadow-2xl">
                        <div className="p-5 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                            <h1 className="font-bold text-xl text-blue-400 italic">108 FACE BLUR</h1>
                            <div className={`w-2.5 h-2.5 rounded-full ${aiStatus==='ready'?'bg-green-500 shadow-[0_0_8px_#22c55e]':'bg-yellow-500 animate-pulse'}`}></div>
                        </div>
                        
                        <div className="flex-1 overflow-y-auto p-5 space-y-6">
                            <div className="flex gap-2">
                                <button onClick={()=>fileRef.current.click()} className="btn flex-1 py-4 bg-blue-600 hover:bg-blue-500 rounded-2xl font-bold flex items-center justify-center gap-2 text-white shadow-lg text-sm">
                                    <Icon p={IconsData.Upload}/> อัปโหลด
                                </button>
                                <button onClick={handleUndo} disabled={history.length === 0} className="btn w-14 bg-slate-700 hover:bg-slate-600 rounded-2xl flex items-center justify-center disabled:opacity-30" title="ย้อนกลับ (Ctrl+Z)">
                                    <Icon p={IconsData.Undo}/>
                                </button>
                            </div>

                            {images.length > 0 && (
                                <div className="flex gap-2 overflow-x-auto py-1 no-scrollbar">
                                    {images.map(img => (
                                        <div key={img.id} onClick={()=>setCurId(img.id)} className={`relative flex-none w-12 h-12 rounded-xl border-2 cursor-pointer transition-all ${curId===img.id?'border-blue-500 scale-105 shadow-lg':'border-transparent opacity-40'}`}>
                                            <img src={img.url} className="w-full h-full object-cover rounded-lg"/>
                                        </div>
                                    ))}
                                </div>
                            )}

                            <hr className="border-slate-700/50"/>

                            {selFace ? (
                                <div className="bg-slate-900/50 border border-blue-500/30 p-5 rounded-[2rem] space-y-5 animate-in fade-in slide-in-from-left-4">
                                    <div className="flex justify-between items-center border-b border-white/5 pb-3">
                                        <span className="text-blue-400 font-bold uppercase text-[10px] tracking-widest">Adjust Point</span>
                                        <button onClick={()=>{saveToHistory(); setImages(prev=>prev.map(img=>img.id===curId?{...img, faces:img.faces.filter(f=>f.id!==selId)}:img)); setSelId(null);}} className="text-red-400 hover:bg-red-400/20 p-2 rounded-full transition-all group" title="ลบจุดนี้">
                                            <Icon p={IconsData.Trash} className="group-hover:scale-110"/>
                                        </button>
                                    </div>
                                    <div className="space-y-4">
                                        <div><div className="flex justify-between text-xs mb-2 text-slate-400"><span>ขนาด</span><span className="text-white">{selFace.w.toFixed(0)}px</span></div><input type="range" min="10" max="2000" value={selFace.w} onChange={e=>{saveToHistory(); updateSel('w', Number(e.target.value))}} className="w-full"/></div>
                                        <div><div className="flex justify-between text-xs mb-2 text-slate-400"><span>ความเบลอ</span><span className="text-white">{selFace.blur}%</span></div><input type="range" min="0" max="100" value={selFace.blur} onChange={e=>updateSel('blur', Number(e.target.value))} className="w-full"/></div>
                                        <div><div className="flex justify-between text-xs mb-2 text-slate-400"><span>ความฟุ้งขอบ</span><span className="text-white">{selFace.soft}%</span></div><input type="range" min="0" max="300" value={selFace.soft} onChange={e=>updateSel('soft', Number(e.target.value))} className="w-full"/></div>
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={()=>updateSel('shape','circle')} className={`flex-1 py-2.5 rounded-xl text-xs border transition-all ${selFace.shape==='circle'?'bg-blue-600 border-blue-500 font-bold':'border-slate-600 text-slate-400'}`}>วงกลม</button>
                                        <button onClick={()=>updateSel('shape','square')} className={`flex-1 py-2.5 rounded-xl text-xs border transition-all ${selFace.shape==='square'?'bg-blue-600 border-blue-500 font-bold':'border-slate-600 text-slate-400'}`}>สี่เหลี่ยม</button>
                                    </div>
                                    <button onClick={()=>setSelId(null)} className="w-full py-3 bg-slate-700 hover:bg-slate-600 rounded-2xl text-sm font-bold mt-2">เสร็จสิ้น</button>
                                </div>
                            ) : (
                                <div className="space-y-6">
                                    <div className="space-y-4 px-1">
                                        <div className="text-slate-500 font-bold uppercase text-[9px] tracking-widest mb-2">Global Settings</div>
                                        <div><div className="flex justify-between text-xs mb-2 px-1 text-slate-400"><span>เบลอพื้นฐาน</span><span>{defBlur}</span></div><input type="range" min="0" max="100" value={defBlur} onChange={e=>updateGlobal('blur', Number(e.target.value))} className="w-full"/></div>
                                        <div><div className="flex justify-between text-xs mb-2 px-1 text-slate-400"><span>ฟุ้งขอบพื้นฐาน</span><span>{defSoft}</span></div><input type="range" min="0" max="200" value={defSoft} onChange={e=>updateGlobal('soft', Number(e.target.value))} className="w-full"/></div>
                                    </div>
                                    <div className="pt-4 border-t border-slate-700/50 space-y-2">
                                        <button onClick={()=>{if(imgRef.current) detectFaces(imgRef.current, curId)}} disabled={isProcessing || aiStatus !== 'ready'} className="w-full py-3.5 bg-slate-700 hover:bg-slate-600 rounded-2xl flex justify-center items-center gap-2 text-sm font-bold transition-all disabled:opacity-30 shadow-inner">
                                            <Icon p={IconsData.Refresh} className={isProcessing?'spinner':''}/> สแกนอัตโนมัติ
                                        </button>
                                        <button onClick={()=>setShowOutlines(!showOutlines)} className="w-full py-3.5 bg-slate-700/30 hover:bg-slate-700/50 rounded-2xl flex justify-center items-center gap-2 text-sm transition-all text-slate-400">
                                            <Icon p={showOutlines?IconsData.Eye:IconsData.EyeOff}/> {showOutlines ? 'ซ่อนกรอบแนะนำ' : 'แสดงกรอบแนะนำ'}
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>

                        {curId && (
                            <div className="p-5 border-t border-slate-700 bg-slate-900/20 backdrop-blur-xl">
                                <button onClick={saveImage} className="w-full py-4.5 bg-green-600 hover:bg-green-500 rounded-2xl font-bold shadow-[0_10px_30px_rgba(22,163,74,0.3)] flex justify-center items-center gap-3 btn text-white text-lg transition-all active:scale-95">
                                    <Icon p={IconsData.Save}/> บันทึกรูปภาพ
                                </button>
                            </div>
                        )}
                    </div>

                    {/* Canvas Container */}
                    <div className="flex-1 bg-slate-950 canvas-container flex items-center justify-center relative overflow-hidden" 
                         onMouseDown={onMouseDown} onMouseMove={onMouseMove} onMouseUp={onMouseUp} 
                         onWheel={(e)=>setScale(s=>Math.max(0.05, Math.min(10, s*(1-e.deltaY*0.001))))}>
                        
                        {!curId ? (
                            <div className="text-center p-20 border border-slate-800 rounded-[4rem] bg-slate-900/30 backdrop-blur-md cursor-pointer hover:border-blue-500/50 transition-all group max-w-lg" onClick={()=>fileRef.current.click()}>
                                <div className="w-24 h-24 bg-slate-800 rounded-[2.5rem] flex items-center justify-center mx-auto mb-8 group-hover:scale-110 group-hover:bg-blue-600 transition-all duration-700 shadow-2xl">
                                    <Icon p={IconsData.Upload} className="w-12 h-12 text-slate-500 group-hover:text-white transition-colors"/>
                                </div>
                                <h2 className="text-3xl font-black text-slate-200 tracking-tight">108 FACE BLUR</h2>
                                <p className="text-slate-500 mt-4 text-sm font-medium tracking-wide font-mono tracking-tighter uppercase italic">Professional PC Edition v15</p>
                            </div>
                        ) : (
                            <div className="relative" style={{width:'100%', height:'100%', display:'flex', alignItems:'center', justifyContent:'center'}}>
                                <canvas ref={canvasRef} className="shadow-[0_20px_80px_rgba(0,0,0,1)] cursor-move border border-white/5 rounded-lg"/>
                                
                                {/* Floating Zoom UI - FIXED: Added onMouseDown stop propagation */}
                                <div className="absolute bottom-8 right-8 flex flex-col gap-4" onMouseDown={(e)=>e.stopPropagation()}>
                                    <button onClick={(e)=>{setScale(s=>Math.min(s*1.3, 10));}} className="w-14 h-14 bg-slate-800/90 backdrop-blur-2xl rounded-3xl text-white shadow-2xl border border-white/10 hover:bg-blue-600 hover:scale-110 transition-all flex items-center justify-center group" title="ซูมเข้า"><Icon p={IconsData.ZoomIn} className="group-hover:scale-125 transition-transform"/></button>
                                    <button onClick={(e)=>{setScale(s=>Math.max(s/1.3, 0.05));}} className="w-14 h-14 bg-slate-800/90 backdrop-blur-2xl rounded-3xl text-white shadow-2xl border border-white/10 hover:bg-blue-600 hover:scale-110 transition-all flex items-center justify-center group" title="ซูมออก"><Icon p={IconsData.ZoomOut} className="group-hover:scale-125 transition-transform"/></button>
                                </div>
                            </div>
                        )}

                        {isProcessing && (
                            <div className="absolute top-10 left-1/2 -translate-x-1/2 z-50 animate-in slide-in-from-top-10 duration-500">
                                <div className="bg-slate-800/90 backdrop-blur border border-blue-500/50 px-8 py-4 rounded-[2.5rem] shadow-[0_20px_50px_rgba(0,0,0,0.5)] flex items-center gap-5 text-white">
                                    <div className="w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                                    <span className="font-bold text-sm">AI กำลังวิเคราะห์ใบหน้า...</span>
                                </div>
                            </div>
                        )}
                        <input ref={fileRef} type="file" className="hidden" multiple accept="image/*" onChange={(e)=>{
                            const files = Array.from(e.target.files);
                            files.forEach(f => {
                                const r = new FileReader(); r.onload=(ev)=>{
                                    const i=new Image(); i.onload=()=>setImages(p=>[...p, {id:Math.random().toString(), url:ev.target.result, faces:[], processed:false}]);
                                    i.src=ev.target.result;
                                }; r.readAsDataURL(f);
                            });
                            e.target.value="";
                        }}/>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
